### 简介
Bigtable是一个分布式的结构化数据库，既能做到高吞吐量，也能做到低延迟，具有良好的可扩展性以及较高的可用性。Bigtable中的数据既可以存储在硬盘中，也可以存储在内存中，而且客户端可以控制数据在底层的存储布局。

### 数据模型
本质来说，Bigtable是key/value(键值)数据库(类似于redis那种)，不过Bigtable更进一步，**支持多个key的联合索引：row key, column key, timestamp**。其中row key相当于数据的名字，column key可看作是数据的属性，timestamp则代表数据的版本。row是字典有序的，名字长度最多可达64KB；在column key之上还有一个column familiy(列簇)的概念，列簇是权限分配的基本单位，属于同一个列簇的列通常数据类型是一样的，column key的标识方式是这样的：`family:qualifier`；timestamp既可以是时间，也可以是用户指定的唯一的64位的标识。下面是本文提供的一个例子：

<img src="https://github.com/zxhcodes/distributed-computing-course/blob/master/2_storage/imgs/bigtable_datamodel.png"/>

### 存储结构
Bigtable包含Master、TabletSever、Chubby等3个主要部分，整体框架如下图所示：


<img src="https://github.com/zxhcodes/distributed-computing-course/blob/master/2_storage/imgs/bigtable_structure.png"/>

Bigtable的底层存储系统为GFS，GFS本身就是可靠的存储系统，所以Bigtable自己没有再做数据备份等操作来保证可用性；Bigtable会将所有的行动态的划分为不同的区域，称为**tablet**，tablet是基本的存储单位(同一个tablet只会属于同一个机器，不会跨机器存储)，tablet的数据既有可能存储在SSTable中，也有可能存储在MEMTable中：其中SSTable是一种特殊的数据格式：有序的、只读的字典，SSTable内部分为多个大小为64KB(可配置)的数据块，其中还有数据块的索引信息，SSTable在被打开的时候，这些索引信息会被加载到内存中(因为有序，所以可使用二分查找来加快定位速度)。MEMTable用来存储最近的更新数据，这些数据在后面会被`minor compaction process`写到SSTable中(当前MEMTable的大小达到上限后，就会被锁住，新来的更新数据写到新的MEMTtable中，当前MEMTable被转成SSTable写到GFS中)，在tablet之上是tabletserver，由它负责具体的tablet定位、与client交互进行数据传输等。

Master更像是一个后台管理系统，对用户来说基本不可见，它的职责是管理tabletserver与tablet，比如说当Master发现某个tabletserver掉线了(失去联系了，不能正常服务了)，则立马将其名下的tablet交由其他tabletserver管理。Master对tabletserver的追踪监控是通过chubby实现的：每一个正常运行着的tabletserver都在chubby里拥有一把属于自己的互斥锁，Master要求tabletserver定期向其汇报锁的状态，如果某个tabletserver说自己的锁丢了或Master联系不上某个tabletserver了，Master就会尝试去获取该tabletserver的锁，如果获取成功了，说明该tabletserver已不能正常服务了，则立马将其剔除，然后将属于它管理的tablet分配给别的tabletserver。
