### 简介
在分布式系统中，为了容错，需要将同一个服务部署多台相互对立的机器上，但同时要保证相同的请求落在不同的机器上所返回的结果是一样的，这就要求这些提供相同服务的机器看到的环境(比如元数据)应该一样的，由此引出了RSM(Replicated State Machine，复制状态机)的概念。

RSM最早是在图灵奖得主Leslie Lamport的著名论文"Time, clocks, and the ordering of events in a distributed system(1978)"论文中提出的，比较系统性的阐述是在Fred Schneider的论文"Implementing fault-tolerant services using the state machine approach(1990)"中。

它的基本思想是一个分布式的RSM系统由很多个replica组成，每个replica是一个状态机，它的状态保存在一组状态变量中。状态机的状态通过并且只能通过外部命令（commands)来改变。比如你可以把MySQL服务器想像成一个状态机。它每接收到一条带修改功能的SQL语句（比如update/insert)就会改变它的状态。一组配置好replication的MySQL servers就是典型的RSM。

RSM能够工作基于这样的假设：如果一些状态机具有相同的初始状态，并且他们接收到的命令也相同，处理这些命令的顺序也相同，那么它们处理完这些命令后的状态也应该相同。 因为replica都具有相同的状态，所以坏掉任何一个也没有关系，有了RSM之后理论上可以做到永远不会因为机器的物理故障而丢失数据。

如何让不同机器上RSM即使在个别replica掉线也能保持一致的问题就是接下来要阐述的一致性问题。

在过去的几十年里，Paxos算法一直是一致性问题的主要解决方案，甚至成了一致性算法的代名词，该算法已经从理论上证明了是正确的，且性能也不错，但理解起来非常困难，以至于很少有人能够正确的将其应用到实际系统中，基于该算法实现的ZooKeeper在公开的细节上也与Paxos算法有了较大的偏差。

为此，本文提出了一种将易于理解作为首要目标的一致性算法：**Raft**，该算法与Paxos的最大区别在于：Raft中有一个处于核心位置的leader，Raft为其赋予了即可能多的权限/功能，而Paxos中的leader则没那么重要，Paxos主要借助leader进行一些性能优化，且leader的选举过程相对独立，对数据一致性没有什么影响。

为了便于理解与实现，Raft将整个一致性问题分为了3个相对独立的子问题：
- 如何选举leader？
- 如何复制日志？
- 如何保证安全？(safety, 确保不同机器上状态机以相同的顺序应用相同的命令，每条命令能且只能应用一次)

### 集群架构
典型的Raft集群中包含5台机器，分为3个角色：`leader`, `follower`, `candidate`。`leader`是整个集群唯一的对外接口，客户端读写都只经过leader，客户端提交过来的日志项(命令)也由leader并行的流向其他节点，刚开始的时候，客户端并不知道这个集群的leader是谁，它会随机的连接一台机器，如果这台机器不是leader，则将该连接重定向至leader；follower可以看作是leader数据的备份节点，负责接收并存储leader发送过来的日志项，完全处于被动(passive)状态: 只监听不请求；集群正常没出错的时候，所有的节点要么是leader，要么是follower，但因leader掉线或网络故障等原因导致某个follower在election timeout内没有收到来自leader的心跳信息的话，该follower就会变为candidate，candidate会向其他节点拉票以期变为leader。

下图是节点之间的状态转移图：

<img src="https://github.com/zxhcodes/distributed-computing-course/blob/master/3_coordination/imgs/raft_status.png" width="500px"/>

### leader选举


### 数据写入(日志复制)


### 读取数据


### 成员变更